{
    "sourceFile": "src/components/FileUploader/UploadTask/services/utils.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1748436561773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748440933923,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,111 @@\n+import mime from \"mime\";\r\n+\r\n+export function checkFileBeforeUpload({\r\n+\tfile,\r\n+\taccept,\r\n+\tmaxSizeMB,\r\n+\tonError,\r\n+}: {\r\n+\tfile: File;\r\n+\taccept: string;\r\n+\tmaxSizeMB: number;\r\n+\tonError: (msg: string) => void;\r\n+}) {\r\n+\tconst acceptList = accept.split(\",\").map((s) => s.trim().toLowerCase());\r\n+\tconst fileExt = \".\" + file.name.split(\".\").pop()?.toLowerCase();\r\n+\tconst fileType = file.type.toLowerCase();\r\n+\tconst typeOk =\r\n+\t\tacceptList.includes(\"*\") ||\r\n+\t\tacceptList.includes(fileExt) ||\r\n+\t\t(acceptList.includes(\"image/*\") && fileType.startsWith(\"image/\"));\r\n+\tif (!typeOk) {\r\n+\t\tonError(\"文件类型不支持\");\r\n+\t\treturn false;\r\n+\t}\r\n+\tif (file.size > maxSizeMB * 1024 * 1024) {\r\n+\t\tonError(`文件不能超过${maxSizeMB}MB`);\r\n+\t\treturn false;\r\n+\t}\r\n+\treturn true;\r\n+}\r\n+\r\n+export function createFileChunks(file: File, chunkSize: number) {\r\n+\tconst chunks = [];\r\n+\tlet cur = 0;\r\n+\twhile (cur < file.size) {\r\n+\t\tchunks.push({\r\n+\t\t\tindex: chunks.length,\r\n+\t\t\tstart: cur,\r\n+\t\t\tend: Math.min(cur + chunkSize, file.size),\r\n+\t\t\tchunk: file.slice(cur, cur + chunkSize),\r\n+\t\t});\r\n+\t\tcur += chunkSize;\r\n+\t}\r\n+\treturn chunks;\r\n+}\r\n+\r\n+export function calcFileMD5WithWorker(\r\n+\tfile: File,\r\n+\tchunkSize: number,\r\n+): Promise<{ fileMD5: string; chunkMD5s: string[] }> {\r\n+\treturn new Promise((resolve, reject) => {\r\n+\t\tconst worker = new Worker(new URL(\"../workers/worker-md5.js\", import.meta.url));\r\n+\t\tworker.postMessage({ file, chunkSize });\r\n+\t\tworker.onmessage = (e) => {\r\n+\t\t\tresolve(e.data);\r\n+\t\t\tworker.terminate();\r\n+\t\t};\r\n+\t\tworker.onerror = (err) => {\r\n+\t\t\treject(err);\r\n+\t\t\tworker.terminate();\r\n+\t\t};\r\n+\t});\r\n+}\r\n+\r\n+export function appendSpeedHistory(\r\n+\thistory: Array<{ time: number; loaded: number }>,\r\n+\ttime: number,\r\n+\tloaded: number,\r\n+\twindowSize: number,\r\n+) {\r\n+\tconst newHistory = [...history, { time, loaded }];\r\n+\tif (newHistory.length > windowSize) newHistory.shift();\r\n+\treturn newHistory;\r\n+}\r\n+\r\n+export function calcSpeedAndLeftTime(\r\n+\thistory: Array<{ time: number; loaded: number }>,\r\n+\tfileSize: number,\r\n+) {\r\n+\tif (history.length < 2) return { speed: 0, leftTime: 0 };\r\n+\tconst first = history[0];\r\n+\tconst last = history[history.length - 1];\r\n+\tconst speed =\r\n+\t\t(last.loaded - first.loaded) / ((last.time - first.time) / 1000);\r\n+\tconst leftBytes = fileSize - last.loaded;\r\n+\tconst leftTime = speed > 0 ? leftBytes / speed : 0;\r\n+\treturn { speed, leftTime };\r\n+}\r\n+\r\n+export function calcTotalSpeed(\r\n+\tspeedInfo: Record<string, { speed: number; leftTime: number }>,\r\n+) {\r\n+\treturn Object.values(speedInfo).reduce((sum, s) => sum + (s.speed || 0), 0);\r\n+}\r\n+\r\n+export function ByteConvert(size: number): string {\r\n+\tif (size < 1024) return size + \" B\";\r\n+\tif (size < 1024 * 1024) return (size / 1024).toFixed(2) + \" KB\";\r\n+\tif (size < 1024 * 1024 * 1024) return (size / 1024 / 1024).toFixed(2) + \" MB\";\r\n+\treturn (size / 1024 / 1024 / 1024).toFixed(2) + \" GB\";\r\n+}\r\n+\r\n+export function checkFileTypeSafe(file: File, allowedTypes: string[]): boolean {\r\n+\tconst extMime = mime.getType(file.name) || \"\";\r\n+\treturn allowedTypes.includes(file.type) && allowedTypes.includes(extMime);\r\n+}\r\n+\r\n export function formatFileSize(size: number): string {\r\n   if (size < 1024) return `${size} B`;\r\n   if (size < 1024 * 1024) return `${(size / 1024).toFixed(2)} KB`;\r\n   if (size < 1024 * 1024 * 1024) return `${(size / 1024 / 1024).toFixed(2)} MB`;\r\n"
                },
                {
                    "date": 1748441167626,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,109 +1,111 @@\n import mime from \"mime\";\r\n \r\n export function checkFileBeforeUpload({\r\n-\tfile,\r\n-\taccept,\r\n-\tmaxSizeMB,\r\n-\tonError,\r\n+  file,\r\n+  accept,\r\n+  maxSizeMB,\r\n+  onError,\r\n }: {\r\n-\tfile: File;\r\n-\taccept: string;\r\n-\tmaxSizeMB: number;\r\n-\tonError: (msg: string) => void;\r\n+  file: File;\r\n+  accept: string;\r\n+  maxSizeMB: number;\r\n+  onError: (msg: string) => void;\r\n }) {\r\n-\tconst acceptList = accept.split(\",\").map((s) => s.trim().toLowerCase());\r\n-\tconst fileExt = \".\" + file.name.split(\".\").pop()?.toLowerCase();\r\n-\tconst fileType = file.type.toLowerCase();\r\n-\tconst typeOk =\r\n-\t\tacceptList.includes(\"*\") ||\r\n-\t\tacceptList.includes(fileExt) ||\r\n-\t\t(acceptList.includes(\"image/*\") && fileType.startsWith(\"image/\"));\r\n-\tif (!typeOk) {\r\n-\t\tonError(\"文件类型不支持\");\r\n-\t\treturn false;\r\n-\t}\r\n-\tif (file.size > maxSizeMB * 1024 * 1024) {\r\n-\t\tonError(`文件不能超过${maxSizeMB}MB`);\r\n-\t\treturn false;\r\n-\t}\r\n-\treturn true;\r\n+  const acceptList = accept.split(\",\").map((s) => s.trim().toLowerCase());\r\n+  const fileExt = \".\" + file.name.split(\".\").pop()?.toLowerCase();\r\n+  const fileType = file.type.toLowerCase();\r\n+  const typeOk =\r\n+    acceptList.includes(\"*\") ||\r\n+    acceptList.includes(fileExt) ||\r\n+    (acceptList.includes(\"image/*\") && fileType.startsWith(\"image/\"));\r\n+  if (!typeOk) {\r\n+    onError(\"文件类型不支持\");\r\n+    return false;\r\n+  }\r\n+  if (file.size > maxSizeMB * 1024 * 1024) {\r\n+    onError(`文件不能超过${maxSizeMB}MB`);\r\n+    return false;\r\n+  }\r\n+  return true;\r\n }\r\n \r\n export function createFileChunks(file: File, chunkSize: number) {\r\n-\tconst chunks = [];\r\n-\tlet cur = 0;\r\n-\twhile (cur < file.size) {\r\n-\t\tchunks.push({\r\n-\t\t\tindex: chunks.length,\r\n-\t\t\tstart: cur,\r\n-\t\t\tend: Math.min(cur + chunkSize, file.size),\r\n-\t\t\tchunk: file.slice(cur, cur + chunkSize),\r\n-\t\t});\r\n-\t\tcur += chunkSize;\r\n-\t}\r\n-\treturn chunks;\r\n+  const chunks = [];\r\n+  let cur = 0;\r\n+  while (cur < file.size) {\r\n+    chunks.push({\r\n+      index: chunks.length,\r\n+      start: cur,\r\n+      end: Math.min(cur + chunkSize, file.size),\r\n+      chunk: file.slice(cur, cur + chunkSize),\r\n+    });\r\n+    cur += chunkSize;\r\n+  }\r\n+  return chunks;\r\n }\r\n \r\n export function calcFileMD5WithWorker(\r\n-\tfile: File,\r\n-\tchunkSize: number,\r\n+  file: File,\r\n+  chunkSize: number\r\n ): Promise<{ fileMD5: string; chunkMD5s: string[] }> {\r\n-\treturn new Promise((resolve, reject) => {\r\n-\t\tconst worker = new Worker(new URL(\"../workers/worker-md5.js\", import.meta.url));\r\n-\t\tworker.postMessage({ file, chunkSize });\r\n-\t\tworker.onmessage = (e) => {\r\n-\t\t\tresolve(e.data);\r\n-\t\t\tworker.terminate();\r\n-\t\t};\r\n-\t\tworker.onerror = (err) => {\r\n-\t\t\treject(err);\r\n-\t\t\tworker.terminate();\r\n-\t\t};\r\n-\t});\r\n+  return new Promise((resolve, reject) => {\r\n+    const worker = new Worker(\r\n+      new URL(\"../workers/worker-md5.js\", import.meta.url)\r\n+    );\r\n+    worker.postMessage({ file, chunkSize });\r\n+    worker.onmessage = (e) => {\r\n+      resolve(e.data);\r\n+      worker.terminate();\r\n+    };\r\n+    worker.onerror = (err) => {\r\n+      reject(err);\r\n+      worker.terminate();\r\n+    };\r\n+  });\r\n }\r\n \r\n export function appendSpeedHistory(\r\n-\thistory: Array<{ time: number; loaded: number }>,\r\n-\ttime: number,\r\n-\tloaded: number,\r\n-\twindowSize: number,\r\n+  history: Array<{ time: number; loaded: number }>,\r\n+  time: number,\r\n+  loaded: number,\r\n+  windowSize: number\r\n ) {\r\n-\tconst newHistory = [...history, { time, loaded }];\r\n-\tif (newHistory.length > windowSize) newHistory.shift();\r\n-\treturn newHistory;\r\n+  const newHistory = [...history, { time, loaded }];\r\n+  if (newHistory.length > windowSize) newHistory.shift();\r\n+  return newHistory;\r\n }\r\n \r\n export function calcSpeedAndLeftTime(\r\n-\thistory: Array<{ time: number; loaded: number }>,\r\n-\tfileSize: number,\r\n+  history: Array<{ time: number; loaded: number }>,\r\n+  fileSize: number\r\n ) {\r\n-\tif (history.length < 2) return { speed: 0, leftTime: 0 };\r\n-\tconst first = history[0];\r\n-\tconst last = history[history.length - 1];\r\n-\tconst speed =\r\n-\t\t(last.loaded - first.loaded) / ((last.time - first.time) / 1000);\r\n-\tconst leftBytes = fileSize - last.loaded;\r\n-\tconst leftTime = speed > 0 ? leftBytes / speed : 0;\r\n-\treturn { speed, leftTime };\r\n+  if (history.length < 2) return { speed: 0, leftTime: 0 };\r\n+  const first = history[0];\r\n+  const last = history[history.length - 1];\r\n+  const speed =\r\n+    (last.loaded - first.loaded) / ((last.time - first.time) / 1000);\r\n+  const leftBytes = fileSize - last.loaded;\r\n+  const leftTime = speed > 0 ? leftBytes / speed : 0;\r\n+  return { speed, leftTime };\r\n }\r\n \r\n export function calcTotalSpeed(\r\n-\tspeedInfo: Record<string, { speed: number; leftTime: number }>,\r\n+  speedInfo: Record<string, { speed: number; leftTime: number }>\r\n ) {\r\n-\treturn Object.values(speedInfo).reduce((sum, s) => sum + (s.speed || 0), 0);\r\n+  return Object.values(speedInfo).reduce((sum, s) => sum + (s.speed || 0), 0);\r\n }\r\n \r\n export function ByteConvert(size: number): string {\r\n-\tif (size < 1024) return size + \" B\";\r\n-\tif (size < 1024 * 1024) return (size / 1024).toFixed(2) + \" KB\";\r\n-\tif (size < 1024 * 1024 * 1024) return (size / 1024 / 1024).toFixed(2) + \" MB\";\r\n-\treturn (size / 1024 / 1024 / 1024).toFixed(2) + \" GB\";\r\n+  if (size < 1024) return size + \" B\";\r\n+  if (size < 1024 * 1024) return (size / 1024).toFixed(2) + \" KB\";\r\n+  if (size < 1024 * 1024 * 1024) return (size / 1024 / 1024).toFixed(2) + \" MB\";\r\n+  return (size / 1024 / 1024 / 1024).toFixed(2) + \" GB\";\r\n }\r\n \r\n export function checkFileTypeSafe(file: File, allowedTypes: string[]): boolean {\r\n-\tconst extMime = mime.getType(file.name) || \"\";\r\n-\treturn allowedTypes.includes(file.type) && allowedTypes.includes(extMime);\r\n+  const extMime = mime.getType(file.name) || \"\";\r\n+  return allowedTypes.includes(file.type) && allowedTypes.includes(extMime);\r\n }\r\n \r\n export function formatFileSize(size: number): string {\r\n   if (size < 1024) return `${size} B`;\r\n"
                },
                {
                    "date": 1748444172260,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n   chunkSize: number\r\n ): Promise<{ fileMD5: string; chunkMD5s: string[] }> {\r\n   return new Promise((resolve, reject) => {\r\n     const worker = new Worker(\r\n-      new URL(\"../workers/worker-md5.js\", import.meta.url)\r\n+      new URL('../workers/worker-md5.ts', import.meta.url)\r\n     );\r\n     worker.postMessage({ file, chunkSize });\r\n     worker.onmessage = (e) => {\r\n       resolve(e.data);\r\n"
                },
                {
                    "date": 1748529187163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,5 +97,67 @@\n           });\r\n           worker.terminate();\r\n         } else if (data.type === \"error\") {\r\n           // 处理错误\r\n-       \n\\ No newline at end of file\n+          console.error(\"calcFileMD5WithWorker: Worker error\", data.error);\r\n+          reject(new Error(data.error));\r\n+          worker.terminate();\r\n+        }\r\n+      };\r\n+\r\n+      worker.onerror = (err) => {\r\n+        console.error(\"calcFileMD5WithWorker: Worker error\", err);\r\n+        reject(err);\r\n+        worker.terminate();\r\n+      };\r\n+\r\n+      // 发送数据到Worker\r\n+      worker.postMessage({ buffer, chunkSize }, [buffer]);\r\n+    } catch (err) {\r\n+      console.error(\"calcFileMD5WithWorker: Error creating worker\", err);\r\n+      reject(err);\r\n+    }\r\n+  });\r\n+}\r\n+\r\n+export function appendSpeedHistory(\r\n+  history: Array<{ time: number; loaded: number }>,\r\n+  time: number,\r\n+  loaded: number,\r\n+  windowSize: number\r\n+) {\r\n+  const newHistory = [...history, { time, loaded }];\r\n+  if (newHistory.length > windowSize) newHistory.shift();\r\n+  return newHistory;\r\n+}\r\n+\r\n+export function calcSpeedAndLeftTime(\r\n+  history: Array<{ time: number; loaded: number }>,\r\n+  fileSize: number\r\n+) {\r\n+  if (history.length < 2) return { speed: 0, leftTime: 0 };\r\n+  const first = history[0];\r\n+  const last = history[history.length - 1];\r\n+  const speed =\r\n+    (last.loaded - first.loaded) / ((last.time - first.time) / 1000);\r\n+  const leftBytes = fileSize - last.loaded;\r\n+  const leftTime = speed > 0 ? leftBytes / speed : 0;\r\n+  return { speed, leftTime };\r\n+}\r\n+\r\n+export function calcTotalSpeed(\r\n+  speedInfo: Record<string, { speed: number; leftTime: number }>\r\n+) {\r\n+  return Object.values(speedInfo).reduce((sum, s) => sum + (s.speed || 0), 0);\r\n+}\r\n+\r\n+export function ByteConvert(size: number): string {\r\n+  if (size < 1024) return size + \" B\";\r\n+  if (size < 1024 * 1024) return (size / 1024).toFixed(2) + \" KB\";\r\n+  if (size < 1024 * 1024 * 1024) return (size / 1024 / 1024).toFixed(2) + \" MB\";\r\n+  return (size / 1024 / 1024 / 1024).toFixed(2) + \" GB\";\r\n+}\r\n+\r\n+export function checkFileTypeSafe(file: File, allowedTypes: string[]): boolean {\r\n+  const extMime = mime.getType(file.name) || \"\";\r\n+  return allowedTypes.includes(file.type) && allowedTypes.includes(extMime);\r\n+}\r\n"
                }
            ],
            "date": 1748436561773,
            "name": "Commit-0",
            "content": "export function formatFileSize(size: number): string {\r\n  if (size < 1024) return `${size} B`;\r\n  if (size < 1024 * 1024) return `${(size / 1024).toFixed(2)} KB`;\r\n  if (size < 1024 * 1024 * 1024) return `${(size / 1024 / 1024).toFixed(2)} MB`;\r\n  return `${(size / 1024 / 1024 / 1024).toFixed(2)} GB`;\r\n}\r\n"
        }
    ]
}