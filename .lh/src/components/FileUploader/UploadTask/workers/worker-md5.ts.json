{
    "sourceFile": "src/components/FileUploader/UploadTask/workers/worker-md5.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1748529110752,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748529120563,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,26 +48,26 @@\n         // 报告进度\r\n         const currentProgress = Math.round(((index + 1) / total) * 100);\r\n         if (currentProgress - lastReportedProgress >= PROGRESS_INTERVAL) {\r\n           self.postMessage({\r\n-            type: 'progress',\r\n+            type: \"progress\",\r\n             progress: currentProgress,\r\n             processedChunks: index + 1,\r\n-            totalChunks: total\r\n+            totalChunks: total,\r\n           });\r\n           lastReportedProgress = currentProgress;\r\n         }\r\n       }\r\n \r\n       // 每批次完成后让出主线程\r\n-      await new Promise(resolve => setTimeout(resolve, 0));\r\n+      await new Promise((resolve) => setTimeout(resolve, 0));\r\n     }\r\n \r\n     const fileMD5 = fileSpark.end();\r\n-    self.postMessage({ type: 'complete', fileMD5, chunkMD5s });\r\n+    self.postMessage({ type: \"complete\", fileMD5, chunkMD5s });\r\n   } catch (error) {\r\n     self.postMessage({\r\n-      type: 'error',\r\n-      error: error.message || '计算MD5时发生错误'\r\n+      type: \"error\",\r\n+      error: error.message || \"计算MD5时发生错误\",\r\n     });\r\n   }\r\n };\r\n"
                },
                {
                    "date": 1748529147775,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,25 @@\n // 引入 spark-md5\r\n+// @ts-ignore: self.importScripts is not in lib.dom.d.ts\r\n importScripts(\"https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js\");\r\n \r\n+// 声明SparkMD5类型，避免TS错误\r\n+declare global {\r\n+  interface Window {\r\n+    SparkMD5: {\r\n+      ArrayBuffer: new () => {\r\n+        append: (buffer: ArrayBuffer) => void;\r\n+        end: () => string;\r\n+      };\r\n+    };\r\n+  }\r\n+}\r\n+\r\n self.onmessage = async function (e) {\r\n   const { file, chunkSize } = e.data;\r\n   const total = Math.ceil(file.size / chunkSize);\r\n-  const chunkMD5s = [];\r\n-  let fileSpark = new self.SparkMD5.ArrayBuffer();\r\n+  const chunkMD5s: string[] = [];\r\n+  const fileSpark = new self.SparkMD5.ArrayBuffer();\r\n \r\n   // 每处理5个分片报告一次进度，减少消息传递频率\r\n   const PROGRESS_INTERVAL = 5;\r\n   let lastReportedProgress = 0;\r\n@@ -48,26 +61,26 @@\n         // 报告进度\r\n         const currentProgress = Math.round(((index + 1) / total) * 100);\r\n         if (currentProgress - lastReportedProgress >= PROGRESS_INTERVAL) {\r\n           self.postMessage({\r\n-            type: \"progress\",\r\n+            type: 'progress',\r\n             progress: currentProgress,\r\n             processedChunks: index + 1,\r\n-            totalChunks: total,\r\n+            totalChunks: total\r\n           });\r\n           lastReportedProgress = currentProgress;\r\n         }\r\n       }\r\n \r\n       // 每批次完成后让出主线程\r\n-      await new Promise((resolve) => setTimeout(resolve, 0));\r\n+      await new Promise(resolve => setTimeout(resolve, 0));\r\n     }\r\n \r\n     const fileMD5 = fileSpark.end();\r\n-    self.postMessage({ type: \"complete\", fileMD5, chunkMD5s });\r\n-  } catch (error) {\r\n+    self.postMessage({ type: 'complete', fileMD5, chunkMD5s });\r\n+  } catch (error: unknown) {\r\n     self.postMessage({\r\n-      type: \"error\",\r\n-      error: error.message || \"计算MD5时发生错误\",\r\n+      type: 'error',\r\n+      error: error instanceof Error ? error.message : '计算MD5时发生错误'\r\n     });\r\n   }\r\n };\r\n"
                },
                {
                    "date": 1748529210955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,6 @@\n // 引入 spark-md5\r\n-// @ts-ignore: self.importScripts is not in lib.dom.d.ts\r\n+// @ts-expect-error: self.importScripts is not in lib.dom.d.ts\r\n importScripts(\"https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js\");\r\n \r\n // 声明SparkMD5类型，避免TS错误\r\n declare global {\r\n"
                },
                {
                    "date": 1748529637538,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,26 +61,26 @@\n         // 报告进度\r\n         const currentProgress = Math.round(((index + 1) / total) * 100);\r\n         if (currentProgress - lastReportedProgress >= PROGRESS_INTERVAL) {\r\n           self.postMessage({\r\n-            type: 'progress',\r\n+            type: \"progress\",\r\n             progress: currentProgress,\r\n             processedChunks: index + 1,\r\n-            totalChunks: total\r\n+            totalChunks: total,\r\n           });\r\n           lastReportedProgress = currentProgress;\r\n         }\r\n       }\r\n \r\n       // 每批次完成后让出主线程\r\n-      await new Promise(resolve => setTimeout(resolve, 0));\r\n+      await new Promise((resolve) => setTimeout(resolve, 0));\r\n     }\r\n \r\n     const fileMD5 = fileSpark.end();\r\n-    self.postMessage({ type: 'complete', fileMD5, chunkMD5s });\r\n+    self.postMessage({ type: \"complete\", fileMD5, chunkMD5s });\r\n   } catch (error: unknown) {\r\n     self.postMessage({\r\n-      type: 'error',\r\n-      error: error instanceof Error ? error.message : '计算MD5时发生错误'\r\n+      type: \"error\",\r\n+      error: error instanceof Error ? error.message : \"计算MD5时发生错误\",\r\n     });\r\n   }\r\n };\r\n"
                },
                {
                    "date": 1748530166272,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,10 +13,34 @@\n     };\r\n   }\r\n }\r\n \r\n+// 初始化时先发送一个准备就绪的消息\r\n+self.postMessage({ type: \"ready\" });\r\n+\r\n self.onmessage = async function (e) {\r\n+  // 如果没有收到数据，直接返回\r\n+  if (!e.data || !e.data.file) {\r\n+    self.postMessage({\r\n+      type: \"error\",\r\n+      error: \"无效的输入数据\"\r\n+    });\r\n+    return;\r\n+  }\r\n+\r\n   const { file, chunkSize } = e.data;\r\n+\r\n+  // 发送开始计算的消息\r\n+  self.postMessage({\r\n+    type: \"progress\",\r\n+    progress: 0,\r\n+    processedChunks: 0,\r\n+    totalChunks: 0\r\n+  });\r\n+\r\n+  // 延迟一小段时间再开始计算，避免阻塞UI线程\r\n+  await new Promise(resolve => setTimeout(resolve, 50));\r\n+\r\n   const total = Math.ceil(file.size / chunkSize);\r\n   const chunkMD5s: string[] = [];\r\n   const fileSpark = new self.SparkMD5.ArrayBuffer();\r\n \r\n@@ -61,26 +85,26 @@\n         // 报告进度\r\n         const currentProgress = Math.round(((index + 1) / total) * 100);\r\n         if (currentProgress - lastReportedProgress >= PROGRESS_INTERVAL) {\r\n           self.postMessage({\r\n-            type: \"progress\",\r\n+            type: 'progress',\r\n             progress: currentProgress,\r\n             processedChunks: index + 1,\r\n-            totalChunks: total,\r\n+            totalChunks: total\r\n           });\r\n           lastReportedProgress = currentProgress;\r\n         }\r\n       }\r\n \r\n       // 每批次完成后让出主线程\r\n-      await new Promise((resolve) => setTimeout(resolve, 0));\r\n+      await new Promise(resolve => setTimeout(resolve, 0));\r\n     }\r\n \r\n     const fileMD5 = fileSpark.end();\r\n-    self.postMessage({ type: \"complete\", fileMD5, chunkMD5s });\r\n+    self.postMessage({ type: 'complete', fileMD5, chunkMD5s });\r\n   } catch (error: unknown) {\r\n     self.postMessage({\r\n-      type: \"error\",\r\n-      error: error instanceof Error ? error.message : \"计算MD5时发生错误\",\r\n+      type: 'error',\r\n+      error: error instanceof Error ? error.message : '计算MD5时发生错误'\r\n     });\r\n   }\r\n };\r\n"
                },
                {
                    "date": 1748530548952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,21 +37,24 @@\n     totalChunks: 0,\r\n   });\r\n \r\n   // 延迟一小段时间再开始计算，避免阻塞UI线程\r\n-  await new Promise((resolve) => setTimeout(resolve, 50));\r\n+  await new Promise((resolve) => setTimeout(resolve, 100));\r\n \r\n   const total = Math.ceil(file.size / chunkSize);\r\n   const chunkMD5s: string[] = [];\r\n   const fileSpark = new self.SparkMD5.ArrayBuffer();\r\n \r\n-  // 每处理5个分片报告一次进度，减少消息传递频率\r\n-  const PROGRESS_INTERVAL = 5;\r\n+  // 增加进度报告间隔，减少消息传递频率\r\n+  const PROGRESS_INTERVAL = 10; // 每10%报告一次进度\r\n   let lastReportedProgress = 0;\r\n \r\n   try {\r\n-    // 分批处理，每批处理10个分片，避免长时间阻塞\r\n-    const BATCH_SIZE = 10;\r\n+    // 减小批处理大小，避免长时间阻塞\r\n+    const BATCH_SIZE = 5;\r\n+    // 批次间隔时间，ms\r\n+    const BATCH_INTERVAL = 10;\r\n+\r\n     for (let batchStart = 0; batchStart < total; batchStart += BATCH_SIZE) {\r\n       const batchEnd = Math.min(batchStart + BATCH_SIZE, total);\r\n \r\n       // 创建当前批次的所有Promise\r\n@@ -75,32 +78,56 @@\n \r\n       // 等待当前批次的所有Promise完成\r\n       const results = await Promise.all(batchPromises);\r\n \r\n-      // 处理结果\r\n+      // 收集结果，但减少状态更新频率\r\n+      let shouldReportProgress = false;\r\n+      let maxIndex = 0;\r\n+\r\n       for (const { index, arrayBuffer, chunkMD5 } of results) {\r\n         // 确保按顺序添加到数组\r\n         chunkMD5s[index] = chunkMD5;\r\n         fileSpark.append(arrayBuffer);\r\n \r\n-        // 报告进度\r\n+        maxIndex = Math.max(maxIndex, index);\r\n+\r\n+        // 检查是否需要报告进度\r\n         const currentProgress = Math.round(((index + 1) / total) * 100);\r\n         if (currentProgress - lastReportedProgress >= PROGRESS_INTERVAL) {\r\n-          self.postMessage({\r\n-            type: \"progress\",\r\n-            progress: currentProgress,\r\n-            processedChunks: index + 1,\r\n-            totalChunks: total,\r\n-          });\r\n+          shouldReportProgress = true;\r\n           lastReportedProgress = currentProgress;\r\n         }\r\n       }\r\n \r\n-      // 每批次完成后让出主线程\r\n-      await new Promise((resolve) => setTimeout(resolve, 0));\r\n+      // 批量报告进度，减少消息传递\r\n+      if (shouldReportProgress) {\r\n+        self.postMessage({\r\n+          type: \"progress\",\r\n+          progress: lastReportedProgress,\r\n+          processedChunks: maxIndex + 1,\r\n+          totalChunks: total,\r\n+        });\r\n+      }\r\n+\r\n+      // 每批次完成后让出主线程，增加间隔时间\r\n+      await new Promise((resolve) => setTimeout(resolve, BATCH_INTERVAL));\r\n     }\r\n \r\n+    // 确保最终进度为100%\r\n+    if (lastReportedProgress < 100) {\r\n+      self.postMessage({\r\n+        type: \"progress\",\r\n+        progress: 100,\r\n+        processedChunks: total,\r\n+        totalChunks: total,\r\n+      });\r\n+    }\r\n+\r\n     const fileMD5 = fileSpark.end();\r\n+\r\n+    // 完成后等待一小段时间再发送结果，避免UI阻塞\r\n+    await new Promise((resolve) => setTimeout(resolve, 20));\r\n+\r\n     self.postMessage({ type: \"complete\", fileMD5, chunkMD5s });\r\n   } catch (error: unknown) {\r\n     self.postMessage({\r\n       type: \"error\",\r\n"
                }
            ],
            "date": 1748529110752,
            "name": "Commit-0",
            "content": "// 引入 spark-md5\r\nimportScripts(\"https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js\");\r\n\r\nself.onmessage = async function (e) {\r\n  const { file, chunkSize } = e.data;\r\n  const total = Math.ceil(file.size / chunkSize);\r\n  const chunkMD5s = [];\r\n  let fileSpark = new self.SparkMD5.ArrayBuffer();\r\n\r\n  // 每处理5个分片报告一次进度，减少消息传递频率\r\n  const PROGRESS_INTERVAL = 5;\r\n  let lastReportedProgress = 0;\r\n\r\n  try {\r\n    // 分批处理，每批处理10个分片，避免长时间阻塞\r\n    const BATCH_SIZE = 10;\r\n    for (let batchStart = 0; batchStart < total; batchStart += BATCH_SIZE) {\r\n      const batchEnd = Math.min(batchStart + BATCH_SIZE, total);\r\n\r\n      // 创建当前批次的所有Promise\r\n      const batchPromises = [];\r\n      for (let i = batchStart; i < batchEnd; i++) {\r\n        const start = i * chunkSize;\r\n        const end = Math.min(file.size, start + chunkSize);\r\n        const chunk = file.slice(start, end);\r\n\r\n        // 将每个分片的处理包装成Promise\r\n        const promise = (async (index) => {\r\n          const arrayBuffer = await chunk.arrayBuffer();\r\n          const chunkSpark = new self.SparkMD5.ArrayBuffer();\r\n          chunkSpark.append(arrayBuffer);\r\n          const chunkMD5 = chunkSpark.end();\r\n          return { index, arrayBuffer, chunkMD5 };\r\n        })(i);\r\n\r\n        batchPromises.push(promise);\r\n      }\r\n\r\n      // 等待当前批次的所有Promise完成\r\n      const results = await Promise.all(batchPromises);\r\n\r\n      // 处理结果\r\n      for (const { index, arrayBuffer, chunkMD5 } of results) {\r\n        // 确保按顺序添加到数组\r\n        chunkMD5s[index] = chunkMD5;\r\n        fileSpark.append(arrayBuffer);\r\n\r\n        // 报告进度\r\n        const currentProgress = Math.round(((index + 1) / total) * 100);\r\n        if (currentProgress - lastReportedProgress >= PROGRESS_INTERVAL) {\r\n          self.postMessage({\r\n            type: 'progress',\r\n            progress: currentProgress,\r\n            processedChunks: index + 1,\r\n            totalChunks: total\r\n          });\r\n          lastReportedProgress = currentProgress;\r\n        }\r\n      }\r\n\r\n      // 每批次完成后让出主线程\r\n      await new Promise(resolve => setTimeout(resolve, 0));\r\n    }\r\n\r\n    const fileMD5 = fileSpark.end();\r\n    self.postMessage({ type: 'complete', fileMD5, chunkMD5s });\r\n  } catch (error) {\r\n    self.postMessage({\r\n      type: 'error',\r\n      error: error.message || '计算MD5时发生错误'\r\n    });\r\n  }\r\n};\r\n"
        }
    ]
}