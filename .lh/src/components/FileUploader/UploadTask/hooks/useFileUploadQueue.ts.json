{
    "sourceFile": "src/components/FileUploader/UploadTask/hooks/useFileUploadQueue.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1748440907419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748441158198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -15,5 +15,79 @@\n   uploadFileChunk,\r\n } from \"../services/api\";\r\n import { useCallback, useEffect, useRef, useState } from \"react\";\r\n \r\n-// ...其余内容与原文件一致，完整迁移...\r\n+/**\r\n+ * 文件上传队列与主流程 Hook\r\n+ * 封装所有上传相关状态与操作，支持分片、秒传、进度、速率、错误等。\r\n+ * @param options.accept 支持的文件类型（如 .png,.jpg,image/*）\r\n+ * @param options.maxSizeMB 最大文件大小（MB）\r\n+ * @param options.multiple 是否多文件上传（未用到，可忽略）\r\n+ * @param options.concurrency 并发上传数\r\n+ * @param options.chunkSize 分片大小（字节）\r\n+ * @param options.uploadUrl 上传接口URL\r\n+ * @param options.checkUrl 秒传接口URL\r\n+ * @param options.mergeUrl 合并接口URL\r\n+ * @param options.headers 请求头\r\n+ * @param options.paramsTransform 参数转换函数\r\n+ * @param options.onSuccess 上传成功回调\r\n+ * @param options.onError 上传错误回调\r\n+ * @param options.onProgress 上传进度回调\r\n+ * @param options.onMergeSuccess 合并成功回调\r\n+ * @param options.onCheckSuccess 秒传成功回调\r\n+ * @param options.maxRetry 最大重试次数\r\n+ * @param options.keepAfterUpload 上传完成后是否保留文件\r\n+ * @param options.removeDelayMs 上传完成后延时移除文件的毫秒数\r\n+ * @param options.onRemoveAfterUpload 上传完成后移除文件的回调\r\n+ * @param options.allowedTypes 允许的文件类型\r\n+ * @param options.apiPrefix 接口前缀\r\n+ * @returns 所有上传相关状态与操作方法\r\n+ */\r\n+export function useFileUploadQueue({\r\n+  accept = \"*\",\r\n+  maxSizeMB = 2048,\r\n+  concurrency = 3,\r\n+  chunkSize = 2 * 1024 * 1024,\r\n+  uploadUrl,\r\n+  checkUrl,\r\n+  mergeUrl,\r\n+  headers,\r\n+  paramsTransform,\r\n+  onSuccess,\r\n+  onError,\r\n+  onProgress,\r\n+  onMergeSuccess,\r\n+  onCheckSuccess,\r\n+  maxRetry = 3,\r\n+  keepAfterUpload = true,\r\n+  removeDelayMs = 2000,\r\n+  onRemoveAfterUpload,\r\n+  allowedTypes = [\"image/png\", \"image/jpeg\", \"image/gif\"],\r\n+  apiPrefix,\r\n+}: {\r\n+  accept?: string;\r\n+  maxSizeMB?: number;\r\n+  multiple?: boolean;\r\n+  concurrency?: number;\r\n+  chunkSize?: number;\r\n+  uploadUrl?: string;\r\n+  checkUrl?: string;\r\n+  mergeUrl?: string;\r\n+  headers?: Record<string, string>;\r\n+  paramsTransform?: (params: any, type: string) => any;\r\n+  onSuccess?: (file: File, res: any) => void;\r\n+  onError?: (file: File, err: Error) => void;\r\n+  onProgress?: (file: File, percent: number) => void;\r\n+  onMergeSuccess?: (file: File, res: any) => void;\r\n+  onCheckSuccess?: (file: File, res: any) => void;\r\n+  maxRetry?: number;\r\n+  keepAfterUpload?: boolean;\r\n+  removeDelayMs?: number;\r\n+  onRemoveAfterUpload?: (\r\n+    file: File,\r\n+    reason: \"upload\" | \"instant\",\r\n+  ) => boolean | void | Promise<boolean | void>;\r\n+  allowedTypes?: string[];\r\n+  apiPrefix?: string;\r\n+}) {\r\n+  // ...原文件全部内容（576行）...\r\n+}\r\n"
                },
                {
                    "date": 1748441438480,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,20 +1,20 @@\n import { Modal, Upload, message } from \"antd\";\r\n import {\r\n-  appendSpeedHistory,\r\n-  calcFileMD5WithWorker,\r\n-  calcSpeedAndLeftTime,\r\n-  calcTotalSpeed,\r\n-  checkFileBeforeUpload,\r\n-  checkFileTypeSafe,\r\n-  createFileChunks,\r\n-} from \"../services/utils\";\r\n+\tappendSpeedHistory,\r\n+\tcalcFileMD5WithWorker,\r\n+\tcalcSpeedAndLeftTime,\r\n+\tcalcTotalSpeed,\r\n+\tcheckFileBeforeUpload,\r\n+\tcheckFileTypeSafe,\r\n+\tcreateFileChunks,\r\n+} from \"../utils\";\r\n import {\r\n-  checkInstantUpload,\r\n-  getFileStatus,\r\n-  mergeFile,\r\n-  uploadFileChunk,\r\n-} from \"../services/api\";\r\n+\tcheckInstantUpload,\r\n+\tgetFileStatus,\r\n+\tmergeFile,\r\n+\tuploadFileChunk,\r\n+} from \"../api\";\r\n import { useCallback, useEffect, useRef, useState } from \"react\";\r\n \r\n /**\r\n  * 文件上传队列与主流程 Hook\r\n@@ -42,52 +42,534 @@\n  * @param options.apiPrefix 接口前缀\r\n  * @returns 所有上传相关状态与操作方法\r\n  */\r\n export function useFileUploadQueue({\r\n-  accept = \"*\",\r\n-  maxSizeMB = 2048,\r\n-  concurrency = 3,\r\n-  chunkSize = 2 * 1024 * 1024,\r\n-  uploadUrl,\r\n-  checkUrl,\r\n-  mergeUrl,\r\n-  headers,\r\n-  paramsTransform,\r\n-  onSuccess,\r\n-  onError,\r\n-  onProgress,\r\n-  onMergeSuccess,\r\n-  onCheckSuccess,\r\n-  maxRetry = 3,\r\n-  keepAfterUpload = true,\r\n-  removeDelayMs = 2000,\r\n-  onRemoveAfterUpload,\r\n-  allowedTypes = [\"image/png\", \"image/jpeg\", \"image/gif\"],\r\n-  apiPrefix,\r\n+\taccept = \"*\",\r\n+\tmaxSizeMB = 2048,\r\n+\tconcurrency = 3,\r\n+\tchunkSize = 2 * 1024 * 1024,\r\n+\tuploadUrl,\r\n+\tcheckUrl,\r\n+\tmergeUrl,\r\n+\theaders,\r\n+\tparamsTransform,\r\n+\tonSuccess,\r\n+\tonError,\r\n+\tonProgress,\r\n+\tonMergeSuccess,\r\n+\tonCheckSuccess,\r\n+\tmaxRetry = 3,\r\n+\tkeepAfterUpload = true,\r\n+\tremoveDelayMs = 2000,\r\n+\tonRemoveAfterUpload,\r\n+\tallowedTypes = [\"image/png\", \"image/jpeg\", \"image/gif\"],\r\n+\tapiPrefix,\r\n }: {\r\n-  accept?: string;\r\n-  maxSizeMB?: number;\r\n-  multiple?: boolean;\r\n-  concurrency?: number;\r\n-  chunkSize?: number;\r\n-  uploadUrl?: string;\r\n-  checkUrl?: string;\r\n-  mergeUrl?: string;\r\n-  headers?: Record<string, string>;\r\n-  paramsTransform?: (params: any, type: string) => any;\r\n-  onSuccess?: (file: File, res: any) => void;\r\n-  onError?: (file: File, err: Error) => void;\r\n-  onProgress?: (file: File, percent: number) => void;\r\n-  onMergeSuccess?: (file: File, res: any) => void;\r\n-  onCheckSuccess?: (file: File, res: any) => void;\r\n-  maxRetry?: number;\r\n-  keepAfterUpload?: boolean;\r\n-  removeDelayMs?: number;\r\n-  onRemoveAfterUpload?: (\r\n-    file: File,\r\n-    reason: \"upload\" | \"instant\"\r\n-  ) => boolean | void | Promise<boolean | void>;\r\n-  allowedTypes?: string[];\r\n-  apiPrefix?: string;\r\n+\taccept?: string;\r\n+\tmaxSizeMB?: number;\r\n+\tmultiple?: boolean;\r\n+\tconcurrency?: number;\r\n+\tchunkSize?: number;\r\n+\tuploadUrl?: string;\r\n+\tcheckUrl?: string;\r\n+\tmergeUrl?: string;\r\n+\theaders?: Record<string, string>;\r\n+\tparamsTransform?: (params: any, type: string) => any;\r\n+\tonSuccess?: (file: File, res: any) => void;\r\n+\tonError?: (file: File, err: Error) => void;\r\n+\tonProgress?: (file: File, percent: number) => void;\r\n+\tonMergeSuccess?: (file: File, res: any) => void;\r\n+\tonCheckSuccess?: (file: File, res: any) => void;\r\n+\tmaxRetry?: number;\r\n+\tkeepAfterUpload?: boolean;\r\n+\tremoveDelayMs?: number;\r\n+\tonRemoveAfterUpload?: (\r\n+\t\tfile: File,\r\n+\t\treason: \"upload\" | \"instant\",\r\n+\t) => boolean | void | Promise<boolean | void>;\r\n+\tallowedTypes?: string[];\r\n+\tapiPrefix?: string;\r\n }) {\r\n-  // ...原文件全部内容（576行）...\r\n+\t/**\r\n+\t * 文件列表\r\n+\t */\r\n+\tconst [files, setFiles] = useState<File[]>([]);\r\n+\t/**\r\n+\t * MD5 及分片MD5信息\r\n+\t */\r\n+\tconst [md5Info, setMd5Info] = useState<\r\n+\t\tRecord<string, { fileMD5: string; chunkMD5s: string[] }>\r\n+\t>({});\r\n+\t/**\r\n+\t * 秒传/分片存在性信息\r\n+\t */\r\n+\tconst [instantInfo, setInstantInfo] = useState<\r\n+\t\tRecord<string, { uploaded: boolean; chunkCheckResult: any[] }>\r\n+\t>({});\r\n+\t/**\r\n+\t * 上传进度与状态\r\n+\t */\r\n+\tconst [uploadingInfo, setUploadingInfo] = useState<\r\n+\t\tRecord<string, { progress: number; status: string }>\r\n+\t>({});\r\n+\t/**\r\n+\t * 当前 loading 文件 key\r\n+\t */\r\n+\tconst [loadingKey, setLoadingKey] = useState<string | null>(null);\r\n+\t/**\r\n+\t * 批量上传中标记\r\n+\t */\r\n+\tconst [uploadingAll, setUploadingAll] = useState(false);\r\n+\t/**\r\n+\t * 速率与剩余时间\r\n+\t */\r\n+\tconst [speedInfo, setSpeedInfo] = useState<\r\n+\t\tRecord<string, { speed: number; leftTime: number }>\r\n+\t>({});\r\n+\t/**\r\n+\t * 速率滑动窗口历史\r\n+\t */\r\n+\tconst speedHistoryRef = useRef<\r\n+\t\tRecord<string, Array<{ time: number; loaded: number }>>\r\n+\t>({});\r\n+\t/**\r\n+\t * 错误信息\r\n+\t */\r\n+\tconst [errorInfo, setErrorInfo] = useState<Record<string, string>>({});\r\n+\r\n+\t/**\r\n+\t * beforeUpload 校验\r\n+\t * @param file 文件对象\r\n+\t * @returns 是否允许上传\r\n+\t */\r\n+\tconst handleBeforeUpload = useCallback(\r\n+\t\t(file: File) => {\r\n+\t\t\t// 文件类型安全校验\r\n+\t\t\tif (!checkFileTypeSafe(file, allowedTypes)) {\r\n+\t\t\t\tmessage.error(\"文件类型不被允许\");\r\n+\t\t\t\treturn Upload.LIST_IGNORE;\r\n+\t\t\t}\r\n+\t\t\tconst ok = checkFileBeforeUpload({\r\n+\t\t\t\tfile,\r\n+\t\t\t\taccept,\r\n+\t\t\t\tmaxSizeMB,\r\n+\t\t\t\tonError: (msg) => message.error(msg),\r\n+\t\t\t});\r\n+\t\t\tif (!ok) return Upload.LIST_IGNORE;\r\n+\t\t\tsetFiles((prev) => {\r\n+\t\t\t\tif (prev.find((f) => f.name === file.name && f.size === file.size))\r\n+\t\t\t\t\treturn prev;\r\n+\t\t\t\treturn [...prev, file];\r\n+\t\t\t});\r\n+\t\t\treturn false; // 阻止自动上传\r\n+\t\t},\r\n+\t\t[accept, maxSizeMB, allowedTypes],\r\n+\t);\r\n+\r\n+\t/**\r\n+\t * 计算MD5并秒传验证\r\n+\t * @param file 文件对象\r\n+\t */\r\n+\tconst handleCalcMD5 = useCallback(\r\n+\t\tasync (file: File) => {\r\n+\t\t\tsetLoadingKey(file.name + file.size);\r\n+\t\t\ttry {\r\n+\t\t\t\tconst result = await calcFileMD5WithWorker(file, chunkSize);\r\n+\t\t\t\tsetMd5Info((prev) => ({ ...prev, [file.name + file.size]: result }));\r\n+\t\t\t\t// message.success(`MD5计算完成: ${result.fileMD5}`);\r\n+\t\t\t\t// 秒传验证\r\n+\t\t\t\tconst fileId = `${result.fileMD5}-${file.name}-${file.size}`;\r\n+\t\t\t\tconst chunks = createFileChunks(file, chunkSize);\r\n+\t\t\t\tconst instantRes = await checkInstantUpload(\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\tfileId,\r\n+\t\t\t\t\t\tmd5: result.fileMD5,\r\n+\t\t\t\t\t\tname: file.name,\r\n+\t\t\t\t\t\tsize: file.size,\r\n+\t\t\t\t\t\ttotal: chunks.length,\r\n+\t\t\t\t\t\tchunkMD5s: result.chunkMD5s,\r\n+\t\t\t\t\t},\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\turl: checkUrl,\r\n+\t\t\t\t\t\tapiPrefix,\r\n+\t\t\t\t\t\theaders,\r\n+\t\t\t\t\t\tparamsTransform,\r\n+\t\t\t\t\t},\r\n+\t\t\t\t);\r\n+\t\t\t\tif (onCheckSuccess) onCheckSuccess(file, instantRes);\r\n+\t\t\t\tsetInstantInfo((prev) => ({\r\n+\t\t\t\t\t...prev,\r\n+\t\t\t\t\t[file.name + file.size]: instantRes,\r\n+\t\t\t\t}));\r\n+\t\t\t\t// 秒传成功也受keepAfterUpload控制\r\n+\t\t\t\tif (instantRes.uploaded && !keepAfterUpload) {\r\n+\t\t\t\t\tsetTimeout(async () => {\r\n+\t\t\t\t\t\tlet shouldRemove = true;\r\n+\t\t\t\t\t\tif (onRemoveAfterUpload) {\r\n+\t\t\t\t\t\t\tconst ret = await onRemoveAfterUpload(file, \"instant\");\r\n+\t\t\t\t\t\t\tif (ret === false) shouldRemove = false;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tif (shouldRemove) {\r\n+\t\t\t\t\t\t\tsetFiles((prev) =>\r\n+\t\t\t\t\t\t\t\tprev.filter((f) => f.name + f.size !== file.name + file.size),\r\n+\t\t\t\t\t\t\t);\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t}, removeDelayMs);\r\n+\t\t\t\t}\r\n+\t\t\t} catch {\r\n+\t\t\t\t// message.error(\"MD5或秒传接口异常\");\r\n+\t\t\t} finally {\r\n+\t\t\t\tsetLoadingKey(null);\r\n+\t\t\t}\r\n+\t\t},\r\n+\t\t[\r\n+\t\t\tchunkSize,\r\n+\t\t\tcheckUrl,\r\n+\t\t\theaders,\r\n+\t\t\tparamsTransform,\r\n+\t\t\tonCheckSuccess,\r\n+\t\t\tkeepAfterUpload,\r\n+\t\t\tremoveDelayMs,\r\n+\t\t\tonRemoveAfterUpload,\r\n+\t\t\tapiPrefix,\r\n+\t\t],\r\n+\t);\r\n+\r\n+\t// 找到所有未计算MD5的文件，依次自动计算\r\n+\tuseEffect(() => {\r\n+\t\tconst unMd5Files = files.filter((f) => !md5Info[f.name + f.size]);\r\n+\t\tif (unMd5Files.length > 0 && !loadingKey) {\r\n+\t\t\t(async () => {\r\n+\t\t\t\tfor (const file of unMd5Files) {\r\n+\t\t\t\t\tawait handleCalcMD5(file);\r\n+\t\t\t\t}\r\n+\t\t\t})();\r\n+\t\t}\r\n+\t}, [files, md5Info, loadingKey, handleCalcMD5]);\r\n+\r\n+\t// 分片上传主流程\r\n+\tconst handleStartUpload = useCallback(\r\n+\t\tasync (file: File, resumeInfo?: any) => {\r\n+\t\t\tconst key = file.name + file.size;\r\n+\t\t\tsetErrorInfo((prev) => ({ ...prev, [key]: \"\" }));\r\n+\t\t\tconst md5 = md5Info[key]?.fileMD5 || resumeInfo?.md5;\r\n+\r\n+\t\t\tif (!md5) {\r\n+\t\t\t\treturn;\r\n+\t\t\t}\r\n+\r\n+\t\t\tconst fileId = `${md5}-${file.name}-${file.size}`;\r\n+\r\n+\t\t\tlet uploadedChunks: number[] = resumeInfo?.uploadedChunks || [];\r\n+\t\t\tif (!resumeInfo) {\r\n+\t\t\t\ttry {\r\n+\t\t\t\t\tuploadedChunks = await getFileStatus({ fileId, md5 }, { apiPrefix });\r\n+\t\t\t\t} catch (err) {\r\n+\t\t\t\t\tconsole.log(err);\r\n+\t\t\t\t\t// 忽略错误，继续执行\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\r\n+\t\t\tconst allChunks = createFileChunks(file, chunkSize);\r\n+\t\t\tconst needUploadChunks = allChunks.filter(\r\n+\t\t\t\t(c) => !uploadedChunks.includes(c.index),\r\n+\t\t\t);\r\n+\r\n+\t\t\tlet uploadedCount = uploadedChunks.length;\r\n+\t\t\tlet uploadedBytes = uploadedChunks.reduce(\r\n+\t\t\t\t(sum, idx) =>\r\n+\t\t\t\t\tsum +\r\n+\t\t\t\t\t(createFileChunks(file, chunkSize)[idx]?.end -\r\n+\t\t\t\t\t\tcreateFileChunks(file, chunkSize)[idx]?.start),\r\n+\t\t\t\t0,\r\n+\t\t\t);\r\n+\r\n+\t\t\tsetUploadingInfo((prev) => ({\r\n+\t\t\t\t...prev,\r\n+\t\t\t\t[key]: {\r\n+\t\t\t\t\tprogress: Math.round((uploadedCount / allChunks.length) * 100),\r\n+\t\t\t\t\tstatus: \"uploading\",\r\n+\t\t\t\t},\r\n+\t\t\t}));\r\n+\r\n+\t\t\tspeedHistoryRef.current[key] = [\r\n+\t\t\t\t{ time: Date.now(), loaded: uploadedBytes },\r\n+\t\t\t];\r\n+\r\n+\t\t\t// 上传每个分片\r\n+\t\t\tfor (const chunk of needUploadChunks) {\r\n+\t\t\t\tlet retry = 0;\r\n+\t\t\t\tlet delay = 500;\r\n+\t\t\t\tconst chunkSizeVal = chunk.end - chunk.start;\r\n+\r\n+\t\t\t\twhile (retry < maxRetry) {\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\tconst uploadResult = await uploadFileChunk(\r\n+\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\tfileId,\r\n+\t\t\t\t\t\t\t\tchunk_md5: md5Info[key].chunkMD5s[chunk.index],\r\n+\t\t\t\t\t\t\t\tindex: chunk.index,\r\n+\t\t\t\t\t\t\t\tchunk: chunk.chunk,\r\n+\t\t\t\t\t\t\t\tname: file.name,\r\n+\t\t\t\t\t\t\t\ttotal: allChunks.length,\r\n+\t\t\t\t\t\t\t},\r\n+\t\t\t\t\t\t\t{\r\n+\t\t\t\t\t\t\t\turl: uploadUrl,\r\n+\t\t\t\t\t\t\t\tapiPrefix,\r\n+\t\t\t\t\t\t\t\theaders,\r\n+\t\t\t\t\t\t\t\tparamsTransform,\r\n+\t\t\t\t\t\t\t},\r\n+\t\t\t\t\t\t);\r\n+\r\n+\t\t\t\t\t\t// 使用服务器返回的MD5值更新本地状态\r\n+\t\t\t\t\t\tif (uploadResult.data?.chunk_md5) {\r\n+\t\t\t\t\t\t\tmd5Info[key].chunkMD5s[chunk.index] = uploadResult.data.chunk_md5;\r\n+\t\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\t\tuploadedCount++;\r\n+\t\t\t\t\t\tuploadedBytes += chunkSizeVal;\r\n+\t\t\t\t\t\tuploadedChunks.push(chunk.index);\r\n+\r\n+\t\t\t\t\t\t// 更新进度\r\n+\t\t\t\t\t\tconst progress = Math.round(\r\n+\t\t\t\t\t\t\t(uploadedCount / allChunks.length) * 100,\r\n+\t\t\t\t\t\t);\r\n+\r\n+\t\t\t\t\t\tsetUploadingInfo((prev) => ({\r\n+\t\t\t\t\t\t\t...prev,\r\n+\t\t\t\t\t\t\t[key]: {\r\n+\t\t\t\t\t\t\t\tprogress,\r\n+\t\t\t\t\t\t\t\tstatus: \"uploading\",\r\n+\t\t\t\t\t\t\t},\r\n+\t\t\t\t\t\t}));\r\n+\r\n+\t\t\t\t\t\t// 更新速度信息\r\n+\t\t\t\t\t\tconst now = Date.now();\r\n+\t\t\t\t\t\tconst prevHistory = speedHistoryRef.current[key] || [];\r\n+\t\t\t\t\t\tspeedHistoryRef.current[key] = appendSpeedHistory(\r\n+\t\t\t\t\t\t\tprevHistory,\r\n+\t\t\t\t\t\t\tnow,\r\n+\t\t\t\t\t\t\tuploadedBytes,\r\n+\t\t\t\t\t\t\t5,\r\n+\t\t\t\t\t\t);\r\n+\t\t\t\t\t\tconst history = speedHistoryRef.current[key];\r\n+\t\t\t\t\t\tif (history.length >= 2) {\r\n+\t\t\t\t\t\t\tconst { speed, leftTime } = calcSpeedAndLeftTime(\r\n+\t\t\t\t\t\t\t\thistory,\r\n+\t\t\t\t\t\t\t\tfile.size,\r\n+\t\t\t\t\t\t\t);\r\n+\t\t\t\t\t\t\tsetSpeedInfo((prev) => ({\r\n+\t\t\t\t\t\t\t\t...prev,\r\n+\t\t\t\t\t\t\t\t[key]: {\r\n+\t\t\t\t\t\t\t\t\tspeed,\r\n+\t\t\t\t\t\t\t\t\tleftTime,\r\n+\t\t\t\t\t\t\t\t},\r\n+\t\t\t\t\t\t\t}));\r\n+\t\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\t\tif (onProgress) {\r\n+\t\t\t\t\t\t\tonProgress(file, progress);\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tbreak;\r\n+\t\t\t\t\t} catch (err: any) {\r\n+\t\t\t\t\t\tretry++;\r\n+\t\t\t\t\t\tif (retry >= maxRetry) {\r\n+\t\t\t\t\t\t\tsetUploadingInfo((prev) => ({\r\n+\t\t\t\t\t\t\t\t...prev,\r\n+\t\t\t\t\t\t\t\t[key]: {\r\n+\t\t\t\t\t\t\t\t\tprogress: Math.round(\r\n+\t\t\t\t\t\t\t\t\t\t(uploadedCount / allChunks.length) * 100,\r\n+\t\t\t\t\t\t\t\t\t),\r\n+\t\t\t\t\t\t\t\t\tstatus: \"error\",\r\n+\t\t\t\t\t\t\t\t},\r\n+\t\t\t\t\t\t\t}));\r\n+\t\t\t\t\t\t\tsetErrorInfo((prev) => ({\r\n+\t\t\t\t\t\t\t\t...prev,\r\n+\t\t\t\t\t\t\t\t[key]: err?.message || \"分片上传失败\",\r\n+\t\t\t\t\t\t\t}));\r\n+\t\t\t\t\t\t\treturn;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tawait new Promise((res) => setTimeout(res, delay));\r\n+\t\t\t\t\t\tdelay = Math.min(delay * 2, 5000);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\r\n+\t\t\t// 所有分片上传完成，开始合并\r\n+\t\t\ttry {\r\n+\t\t\t\tconst mergeResult = await mergeFile(\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\tfileId,\r\n+\t\t\t\t\t\tmd5,\r\n+\t\t\t\t\t\tname: file.name,\r\n+\t\t\t\t\t\tsize: file.size,\r\n+\t\t\t\t\t\ttotal: allChunks.length,\r\n+\t\t\t\t\t},\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\turl: mergeUrl,\r\n+\t\t\t\t\t\tapiPrefix,\r\n+\t\t\t\t\t\theaders,\r\n+\t\t\t\t\t\tparamsTransform,\r\n+\t\t\t\t\t},\r\n+\t\t\t\t);\r\n+\r\n+\t\t\t\tsetUploadingInfo((prev) => ({\r\n+\t\t\t\t\t...prev,\r\n+\t\t\t\t\t[key]: { progress: 100, status: \"done\" },\r\n+\t\t\t\t}));\r\n+\t\t\t\tsetSpeedInfo((prev) => ({ ...prev, [key]: { speed: 0, leftTime: 0 } }));\r\n+\t\t\t\tsetErrorInfo((prev) => ({ ...prev, [key]: \"\" }));\r\n+\r\n+\t\t\t\tif (onMergeSuccess) onMergeSuccess(file, mergeResult);\r\n+\t\t\t\tif (onSuccess) onSuccess(file, mergeResult);\r\n+\r\n+\t\t\t\t// 自动移除已上传文件\r\n+\t\t\t\tif (!keepAfterUpload) {\r\n+\t\t\t\t\tsetTimeout(async () => {\r\n+\t\t\t\t\t\tlet shouldRemove = true;\r\n+\t\t\t\t\t\tif (onRemoveAfterUpload) {\r\n+\t\t\t\t\t\t\tconst ret = await onRemoveAfterUpload(file, \"upload\");\r\n+\t\t\t\t\t\t\tif (ret === false) shouldRemove = false;\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t\tif (shouldRemove) {\r\n+\t\t\t\t\t\t\tsetFiles((prev) => prev.filter((f) => f.name + f.size !== key));\r\n+\t\t\t\t\t\t}\r\n+\t\t\t\t\t}, removeDelayMs);\r\n+\t\t\t\t}\r\n+\t\t\t} catch (err: any) {\r\n+\t\t\t\tsetUploadingInfo((prev) => ({\r\n+\t\t\t\t\t...prev,\r\n+\t\t\t\t\t[key]: { progress: 100, status: \"merge-error\" },\r\n+\t\t\t\t}));\r\n+\t\t\t\tsetErrorInfo((prev) => ({\r\n+\t\t\t\t\t...prev,\r\n+\t\t\t\t\t[key]: err?.message || \"合并失败\",\r\n+\t\t\t\t}));\r\n+\t\t\t\tif (onError) onError(file, err);\r\n+\t\t\t\tModal.error({\r\n+\t\t\t\t\ttitle: \"合并失败\",\r\n+\t\t\t\t\tcontent: err?.message || \"合并失败\",\r\n+\t\t\t\t});\r\n+\t\t\t}\r\n+\t\t},\r\n+\t\t[\r\n+\t\t\tmd5Info,\r\n+\t\t\tchunkSize,\r\n+\t\t\tuploadUrl,\r\n+\t\t\tcheckUrl,\r\n+\t\t\tmergeUrl,\r\n+\t\t\theaders,\r\n+\t\t\tparamsTransform,\r\n+\t\t\tonSuccess,\r\n+\t\t\tonError,\r\n+\t\t\tonProgress,\r\n+\t\t\tonMergeSuccess,\r\n+\t\t\tmaxRetry,\r\n+\t\t\tkeepAfterUpload,\r\n+\t\t\tremoveDelayMs,\r\n+\t\t\tonRemoveAfterUpload,\r\n+\t\t\tapiPrefix,\r\n+\t\t],\r\n+\t);\r\n+\r\n+\t// 重试单个文件\r\n+\tconst handleRetry = useCallback(\r\n+\t\t(file: File) => {\r\n+\t\t\thandleStartUpload(file);\r\n+\t\t},\r\n+\t\t[handleStartUpload],\r\n+\t);\r\n+\r\n+\t// 重试所有失败文件\r\n+\tconst handleRetryAllFailed = useCallback(async () => {\r\n+\t\tconst failedFiles = files.filter((file) => {\r\n+\t\t\tconst key = file.name + file.size;\r\n+\t\t\tconst uploading = uploadingInfo[key];\r\n+\t\t\treturn (\r\n+\t\t\t\tuploading &&\r\n+\t\t\t\t(uploading.status === \"error\" || uploading.status === \"merge-error\")\r\n+\t\t\t);\r\n+\t\t});\r\n+\t\tfor (const file of failedFiles) {\r\n+\t\t\tawait handleStartUpload(file);\r\n+\t\t}\r\n+\t\t// message.success(\"所有失败文件已重试\");\r\n+\t}, [files, uploadingInfo, handleStartUpload]);\r\n+\r\n+\t// 批量上传自动补齐MD5\r\n+\tconst handleStartAll = useCallback(async () => {\r\n+\t\tsetUploadingAll(true);\r\n+\t\t// 先为所有未计算MD5的文件自动计算MD5\r\n+\t\tfor (const file of files) {\r\n+\t\t\tconst key = file.name + file.size;\r\n+\t\t\tif (!md5Info[key]) {\r\n+\t\t\t\tawait handleCalcMD5(file);\r\n+\t\t\t}\r\n+\t\t}\r\n+\t\t// 过滤出未秒传且未上传完成的文件\r\n+\t\tconst needUploadFiles = files.filter((file) => {\r\n+\t\t\tconst key = file.name + file.size;\r\n+\t\t\tconst instant = instantInfo[key];\r\n+\t\t\tconst uploading = uploadingInfo[key];\r\n+\t\t\treturn (\r\n+\t\t\t\tmd5Info[key] &&\r\n+\t\t\t\t!instant?.uploaded &&\r\n+\t\t\t\t(!uploading || uploading.status !== \"done\")\r\n+\t\t\t);\r\n+\t\t});\r\n+\t\t// 并发控制\r\n+\t\tlet idx = 0;\r\n+\t\tconst queue: Promise<void>[] = [];\r\n+\t\tconst next = async () => {\r\n+\t\t\tif (idx >= needUploadFiles.length) return;\r\n+\t\t\tconst file = needUploadFiles[idx++];\r\n+\t\t\tawait handleStartUpload(file);\r\n+\t\t\tawait next();\r\n+\t\t};\r\n+\t\tfor (let i = 0; i < Math.min(concurrency, needUploadFiles.length); i++) {\r\n+\t\t\tqueue.push(next());\r\n+\t\t}\r\n+\t\tawait Promise.all(queue);\r\n+\t\tsetUploadingAll(false);\r\n+\t\t// message.success(\"全部上传任务已完成\");\r\n+\t}, [\r\n+\t\tfiles,\r\n+\t\tmd5Info,\r\n+\t\tinstantInfo,\r\n+\t\tuploadingInfo,\r\n+\t\thandleCalcMD5,\r\n+\t\thandleStartUpload,\r\n+\t\tconcurrency,\r\n+\t]);\r\n+\r\n+\t// 单个文件上传按钮自动补齐MD5\r\n+\tconst handleStartUploadWithAutoMD5 = useCallback(\r\n+\t\tasync (file: File) => {\r\n+\t\t\tconst key = file.name + file.size;\r\n+\t\t\tif (!md5Info[key]) {\r\n+\t\t\t\tawait handleCalcMD5(file);\r\n+\t\t\t}\r\n+\t\t\tawait handleStartUpload(file);\r\n+\t\t},\r\n+\t\t[md5Info, handleCalcMD5, handleStartUpload],\r\n+\t);\r\n+\r\n+\treturn {\r\n+\t\tfiles,\r\n+\t\tsetFiles,\r\n+\t\tmd5Info,\r\n+\t\tinstantInfo,\r\n+\t\tuploadingInfo,\r\n+\t\tloadingKey,\r\n+\t\tuploadingAll,\r\n+\t\tspeedInfo,\r\n+\t\terrorInfo,\r\n+\t\thandleBeforeUpload,\r\n+\t\thandleCalcMD5,\r\n+\t\thandleStartUpload,\r\n+\t\thandleStartAll,\r\n+\t\thandleRetry,\r\n+\t\thandleRetryAllFailed,\r\n+\t\thandleStartUploadWithAutoMD5,\r\n+\t\tcalcTotalSpeed,\r\n+\t};\r\n }\r\n"
                }
            ],
            "date": 1748440907419,
            "name": "Commit-0",
            "content": "import { Modal, Upload, message } from \"antd\";\r\nimport {\r\n\tappendSpeedHistory,\r\n\tcalcFileMD5WithWorker,\r\n\tcalcSpeedAndLeftTime,\r\n\tcalcTotalSpeed,\r\n\tcheckFileBeforeUpload,\r\n\tcheckFileTypeSafe,\r\n\tcreateFileChunks,\r\n} from \"../services/utils\";\r\nimport {\r\n\tcheckInstantUpload,\r\n\tgetFileStatus,\r\n\tmergeFile,\r\n\tuploadFileChunk,\r\n} from \"../services/api\";\r\nimport { useCallback, useEffect, useRef, useState } from \"react\";\r\n\r\n// ...其余内容与原文件一致，完整迁移..."
        }
    ]
}